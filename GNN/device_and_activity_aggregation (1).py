# -*- coding: utf-8 -*-
"""Device and Activity Aggregation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HPrbliuxQObdse49d7Hep3b4PfcBvMWZ
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA

def load_data(features_path, edge_index_path):
    features_data = pd.read_csv('adjusted_users.csv')
    edge_index_data = pd.read_csv('edge.csv')
    return features_data, edge_index_data

def generate_labels(num_nodes, normal_prob=0.7):
    return np.random.choice(['normal', 'malicious'], size=num_nodes, p=[normal_prob, 1 - normal_prob])

def filter_edges(edge_index_data, labels):
    device_ids = edge_index_data['source'].values
    account_ids = edge_index_data['target'].values
    normal_accounts = edge_index_data[labels[account_ids] == 'normal']
    malicious_accounts = edge_index_data[labels[account_ids] == 'malicious']
    return normal_accounts, malicious_accounts

def plot_aggregation(normal_accounts, malicious_accounts):
    plt.figure(figsize=(12, 6))

    # Plot for Normal Accounts
    plt.subplot(1, 2, 1)
    plt.scatter(normal_accounts['source'], normal_accounts['target'], s=1, alpha=0.5, label='Normal', color='blue')
    plt.title("Device Aggregation: Normal Accounts")
    plt.xlabel("Device ID")
    plt.ylabel("Account ID")
    plt.legend()

    # Plot for Malicious Accounts
    plt.subplot(1, 2, 2)
    plt.scatter(malicious_accounts['source'], malicious_accounts['target'], s=1, alpha=0.5, label='Malicious', color='red')
    plt.title("Device Aggregation: Malicious Accounts")
    plt.xlabel("Device ID")
    plt.ylabel("Account ID")
    plt.legend()

    plt.tight_layout()
    plt.show()

def main():
    features_path = 'adjusted_users.csv'
    edge_index_path = 'edge.csv'

    features_data, edge_index_data = load_data(features_path, edge_index_path)

    num_nodes = max(edge_index_data['source'].max(), edge_index_data['target'].max()) + 1
    labels = generate_labels(num_nodes)

    normal_accounts, malicious_accounts = filter_edges(edge_index_data, labels)

    plot_aggregation(normal_accounts, malicious_accounts)

if __name__ == "__main__":
    main()

def load_data(features_path, edge_index_path):
    processed_features = pd.read_csv('adjusted_users.csv')
    processed_edge_index = pd.read_csv('edge.csv')
    return processed_features, processed_edge_index

def generate_synthetic_activity_time(num_nodes):
    return np.random.randint(0, 144, size=num_nodes)

def generate_labels(num_nodes, normal_prob=0.7):
    return np.random.choice(['normal', 'malicious'], size=num_nodes, p=[normal_prob, 1 - normal_prob])

def annotate_edge_data(edge_index, activity_time, labels):
    node_to_time = {node: time for node, time in enumerate(activity_time)}
    node_to_label = {node: label for node, label in enumerate(labels)}

    edge_index['activity_time'] = edge_index['target'].map(node_to_time)
    edge_index['label'] = edge_index['target'].map(node_to_label)
    return edge_index

def plot_activity_aggregation(edge_index):
    normal_accounts = edge_index[edge_index['label'] == 'normal']
    malicious_accounts = edge_index[edge_index['label'] == 'malicious']

    plt.figure(figsize=(12, 6))

    # Plot for Normal Accounts
    plt.subplot(1, 2, 1)
    plt.scatter(normal_accounts['activity_time'], normal_accounts['target'], s=1, alpha=0.5, label='Normal', color='blue')
    plt.title("Activity Aggregation: Normal Accounts")
    plt.xlabel("Time (in hours)")
    plt.ylabel("Account ID")
    plt.legend()

    # Plot for Malicious Accounts
    plt.subplot(1, 2, 2)
    plt.scatter(malicious_accounts['activity_time'], malicious_accounts['target'], s=1, alpha=0.5, label='Malicious', color='red')
    plt.title("Activity Aggregation: Malicious Accounts")
    plt.xlabel("Time (in hours)")
    plt.ylabel("Account ID")
    plt.legend()

    plt.tight_layout()
    plt.show()

def main():
    features_path = 'adjusted_users.csv'
    edge_index_path = 'edge.csv'

    processed_features, processed_edge_index = load_data(features_path, edge_index_path)

    num_nodes = max(processed_edge_index['target'].max(), processed_edge_index['source'].max()) + 1
    synthetic_activity_time = generate_synthetic_activity_time(num_nodes)
    labels = generate_labels(num_nodes)

    processed_edge_index = annotate_edge_data(processed_edge_index, synthetic_activity_time, labels)

    plot_activity_aggregation(processed_edge_index)

if __name__ == "__main__":
    main()

def load_data(features_path, edge_index_path):
    processed_features = pd.read_csv('adjusted_users.csv')
    processed_edge_index = pd.read_csv('edge.csv')
    return processed_features, processed_edge_index

def compute_degrees(edge_index):
    node_degrees = pd.concat([edge_index['source'], edge_index['target']]).value_counts()
    device_degrees = edge_index['source'].value_counts()
    account_degrees = edge_index['target'].value_counts()
    return node_degrees, device_degrees, account_degrees

def assign_labels(num_nodes, edge_index):
    labels = np.random.choice(['normal', 'malicious'], size=num_nodes, p=[0.7, 0.3])
    edge_index['label'] = edge_index['target'].map({i: labels[i] for i in range(num_nodes)})
    return edge_index, labels

def plot_degree_distributions(node_degrees, device_degrees, account_degrees, normal_accounts, malicious_accounts):
    plt.figure(figsize=(15, 5))

    plt.subplot(1, 3, 1)
    plt.hist(node_degrees, bins=30, alpha=0.7, color='purple')
    plt.title("Node Degree Distribution")
    plt.xlabel("Degree")
    plt.ylabel("Frequency")

    plt.subplot(1, 3, 2)
    plt.hist(device_degrees, bins=30, alpha=0.7, color='blue')
    plt.title("Device Connectivity")
    plt.xlabel("Number of Accounts Linked")
    plt.ylabel("Frequency")

    plt.subplot(1, 3, 3)
    plt.hist(normal_accounts['target'].value_counts(), bins=30, alpha=0.7, label='Normal', color='green')
    plt.hist(malicious_accounts['target'].value_counts(), bins=30, alpha=0.7, label='Malicious', color='red')
    plt.title("Account Connectivity by Label")
    plt.xlabel("Degree (Number of Connections)")
    plt.ylabel("Frequency")
    plt.legend()

    plt.tight_layout()
    plt.show()

def main():
    features_path = 'adjusted_users.csv'
    edge_index_path = 'edge.csv'

    processed_features, processed_edge_index = load_data(features_path, edge_index_path)

    node_degrees, device_degrees, account_degrees = compute_degrees(processed_edge_index)

    num_nodes = max(processed_edge_index['source'].max(), processed_edge_index['target'].max()) + 1
    processed_edge_index, labels = assign_labels(num_nodes, processed_edge_index)

    normal_accounts = processed_edge_index[processed_edge_index['label'] == 'normal']
    malicious_accounts = processed_edge_index[processed_edge_index['label'] == 'malicious']

    plot_degree_distributions(node_degrees, device_degrees, account_degrees, normal_accounts, malicious_accounts)

if __name__ == "__main__":
    main()

def load_features(features_path):
    processed_features = pd.read_csv('adjusted_users.csv')
    node_features = processed_features.values
    return node_features

def generate_labels(num_nodes, normal_prob=0.7):
    return np.random.choice(['normal', 'malicious'], size=num_nodes, p=[normal_prob, 1 - normal_prob])

def reduce_features_with_pca(node_features, n_components=2):
    pca = PCA(n_components=n_components)
    return pca.fit_transform(node_features)

def cluster_and_visualize(reduced_features, labels):
    clusters = np.where(labels == 'normal', 0, 1)
    colors = ['green', 'red']

    plt.figure(figsize=(8, 6))
    for cluster_id in [0, 1]:
        cluster_indices = (clusters == cluster_id)
        cluster_label = 'Normal' if cluster_id == 0 else 'Malicious'
        plt.scatter(
            reduced_features[cluster_indices, 0],
            reduced_features[cluster_indices, 1],
            s=10,
            color=colors[cluster_id],
            label=f'{cluster_label} Cluster'
        )

    plt.title("Clustering of Node Features (Normal vs. Malicious)")
    plt.xlabel("PCA Component 1")
    plt.ylabel("PCA Component 2")
    plt.legend()
    plt.tight_layout()
    plt.show()

def main():
    features_path = 'adjusted_users.csv'

    node_features = load_features(features_path)

    labels = generate_labels(node_features.shape[0])

    reduced_features = reduce_features_with_pca(node_features)

    cluster_and_visualize(reduced_features, labels)

if __name__ == "__main__":
    main()